---
title: "R para Análise Científica Reproduzível"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r, include=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE
               , cache.path="cache/"
               , fig.path="imagens/"
               , dpi=100
               , fig.align="center"
               , comment=NA
               , warning=FALSE
               , error=FALSE
               , message=FALSE)

options(width=100)
```

# Subconjuntos (*subsets*) de dados

***
> Visão Geral:

* **Ensino:** 35 min
* **Exercícios:** 15 min

* **Perguntas**
    + Como eu posso trabalhar com subconjuntos de dados no R?

* **Objetivos**
    + Ser capaz de criar subconjuntos de vetores, fatores, matrizes, listas, e bancos de
      dados (*data frames*)
    + Ser capaz de extrair elementos individuais e múltiplos: por indexador, por nome, e
      usando operações de comparação
    + Ser capaz de pular e remover elementos de várias estruturas de dados.

***

O R tem vários operadores poderosos para subconjuntos e o domínio deles irá permitir que
você facilmente utilize operações complexas em qualquer tipo de conjunto de dados.

Existem seis diferentes maneiras de nós criarmos subconjuntos de qualquer tipo de objeto, e
três diferentes operadores de subconjuntos para as diferentes estruturas de dados.

Vamos começar com o carro chefe do R: vetores atômicos.

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

Então, agora que nós criamos um vetor *dummy* para brincar, como nós temos acesso ao seu
conteúdo?

## Acessando elementos usando seus índices

Para extrair elementos de um vetor nós podemos dar seus correspondentes índices, começando
por um:

```{r}
x[1]

x[4]
```

Isso pode parecer diferente, mas o operador par de colchetes é uma função. Para vetores
atômicos (e matrizes), isso significa "me passe o *n*-ésimo elemento".

Nós podemos pedir por múltiplos elementos de uma única vez:

```{r}
x[c(1, 3)]
```

Ou fatias do vetor:

```{r}
x[1:4]
```

O operador : cria uma sequência de números do elemento da esquerda até o da direita.

```{r}
1:4

c(1, 2, 3, 4)
```

Nós podemos pedir pelo mesmo elemento múltiplas vezes:

```{r}
x[c(1, 1, 3)]
```

Se nós pedirmos por um número fora do vetor, o R retornará valores faltantes:

```{r}
x[6]
```

Este é um vetor de comprimento um contendo um `NA`, cujo nome é também `NA`.

Se nós pedirmos pelo elemento de índice 0, nós temos um vetor vazio:

```{r}
x[0]
```

***
> <p><img src="tap.JPG" align="middle"> Numeração de vetores no R começa em 1</p>

Em várias linguagens de programação (C e python, por exemplo), o primeiro elemento de um
vetor possuí um indexador igual a 0. Em R, o primeiro elemento é 1.

***

## Pulando e removendo elementos

Se nós usarmos como indexador de um vetor um número negativo, o R irá retornar todo elemento
*exceto* o elemento específicado:

```{r}
x[-2]
```

Nós podemos pular múltiplos elementos:

```{r}
x[c(-1, -5)] # ou x[-c(1, 5)]
```

***
> <p><img src="tap.JPG" align="middle"> Dica: Ordem de operações</p>

Uma experiência em comum para os novatos ocorre quando se tenta pular pedaços de um vetor. A
maioria das pessoas primeiro tenta negar uma sequência, como por exemplo:

```{r, eval=FALSE}
x[-1:3]
```

Isto retorna uma espécie de erro crítico:

```{r, error=TRUE, echo=FALSE}
x[-1:3]
```

Mas lembre da ordem das operações. : é realmente uma função, então o que acontece é que ele
pega seu primento argumento como -1, o segundo como 3, e então gera a sequência de números:
`c(-1, 0, 1, 2, 3)`.

A solução correta é colocar o que a função chama em parênteses, assim o operador `-` é
aplicado ao resultado:

```{r}
x[-(1:3)]
```
***

Para remover elementos de um vetor, nós precisamos atribuir o resultado novamente na
variável:

```{r}
x <- x[-4]
x
```

***
<input type=button id=toggle_d1 value="Desafio 1"></input>

Dado o código a seguir:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Forneça ao menos 3 diferentes comandos que produzem o seguinte resultado:

```{r, echo=FALSE}
y <- c(6.2, 7.1, 4.8) ; names(y) <- c('b', 'c', 'd') ; y
```

Depois de você encontrar 3 diferentes comandos, compare anotações com seu colega. Vocês
tiveram diferentes estratégias?

***

<input type=button id=toggle_d2 value="Resposta do desafio 1"></input>

```{r}
x[2:4]

x[-c(1, 5)]

x[c("b", "c", "d")]

x[c(2, 3, 4)]
```

***
<script>
$("#toggle_d1").parent().next().hide();
$("#toggle_d1").parent().next().next().hide();
$("#toggle_d1").parent().next().next().next().hide();
$("#toggle_d1").parent().next().next().next().next().hide();
$("#toggle_d1").parent().next().next().next().next().next().hide();
$("#toggle_d1").parent().next().next().next().next().next().next().hide();
$("#toggle_d1").parent().next().next().next().next().next().next().next().hide();
$("#toggle_d1").parent().next().next().next().next().next().next().next().next().hide();
$("#toggle_d1").on( "click", function(){
  $("#toggle_d1").parent().next().toggle();
  $("#toggle_d1").parent().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().next().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().next().next().next().next().toggle();
  $("#toggle_d1").parent().next().next().next().next().next().next().next().next().toggle();
} );
$("#toggle_d2").parent().next().hide();
$("#toggle_d2").parent().next().next().hide();
$("#toggle_d2").parent().next().next().next().hide();
$("#toggle_d2").parent().next().next().next().next().hide();
$("#toggle_d2").parent().next().next().next().next().next().hide();
$("#toggle_d2").parent().next().next().next().next().next().next().hide();
$("#toggle_d2").parent().next().next().next().next().next().next().next().hide();
$("#toggle_d2").parent().next().next().next().next().next().next().next().next().hide();
$("#toggle_d2").on( "click", function(){
  $("#toggle_d2").parent().next().toggle();
  $("#toggle_d2").parent().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().next().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().next().next().next().next().toggle();
  $("#toggle_d2").parent().next().next().next().next().next().next().next().next().toggle();
} );
</script>

## Subconjuntos por nome

Nós podemos extrair elementos através de seu nome, invés do indexador:

```{r}
x[c("a", "c")]
```

Esta é uma maneira muito mais confiável de dividir objetos: a posição de vários elementos
pode frequentemente mudar quando encadeamos operações de subconjuntos, mas os nomes sempre
permanecerão os mesmos!

Infelizmente não podemos pular ou remover elementos tão facilmente.

Para pular (ou remover) um único elemento nomeado:

```{r}
x[-which(names(x) == "a")]
```

A função `which` retorna os índices de todos os elementos `TRUE` de seu argumento. Lembre
que expressões são avaliadas antes de serem passadas para funções. Vamos mostrar passo à
passo para ficar claro o que está acontecendo.

Primeiro isso acontece:

```{r}
names(x) == "a"
```

O operador condicional é aplicado a todo nome do vetor `x`. Apenas o primeiro nome é `a` e
por isso seu elemento é `TRUE`.

`which` então converte isto para um indexador:

```{r}
which(names(x) == "a")
```

Apenas o primeiro elemento é `TRUE`, então `which` retorna 1. Agora que temos índices 
podemos pular um elemento, pois temos um index negativo!

Pular múltiplos índices nomeados é similar, mas usa um operador de comparação diferente:

```{r}
x[-which(names(x) %in% c("a", "c"))]
```

O `%in%` vai em cada elemento de seu argumento à esquerda, nesse caso os nomes de `x`, e
pergunta, "Esse elemento ocorre no segundo argumento?"

***